import { Component, ContentChildren, Directive, ElementRef, EventEmitter, forwardRef, HostListener, Input, NgZone, Output, QueryList, TemplateRef, ViewChild, ViewEncapsulation } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
/**
 * The NgxToggleLabel directive allows you to customize the label for the "On" and "Off" states,
 * allowing for more robust and complex displays.
 * This directive must be used in conjunction with a ng-template.
 */
var NgxToggleLabel = /** @class */ (function () {
    function NgxToggleLabel(templateRef, elRef) {
        this.templateRef = templateRef;
        this.elRef = elRef;
    }
    Object.defineProperty(NgxToggleLabel.prototype, "element", {
        get: function () {
            return this.elRef;
        },
        enumerable: true,
        configurable: true
    });
    NgxToggleLabel.decorators = [
        { type: Directive, args: [{ selector: 'ng-template[ngxToggleLabel]' },] },
    ];
    /** @nocollapse */
    NgxToggleLabel.ctorParameters = function () { return [
        { type: TemplateRef },
        { type: ElementRef }
    ]; };
    NgxToggleLabel.propDecorators = {
        forLabel: [{ type: Input }]
    };
    return NgxToggleLabel;
}());
export { NgxToggleLabel };
/**
 * The NgxToggle directive allows for standalone or checkbox-enabled switch toggling via a UI element.
 * The toggle is styled using Bootstrap v4+ classes.
 */
var NgxToggle = /** @class */ (function () {
    function NgxToggle(ngZone, elRef) {
        this.ngZone = ngZone;
        this.elRef = elRef;
        /**
         * Display text when toggled in the "On" position
         * @type {string}
         */
        this.onText = 'On';
        /**
         * Display text when toggled in the "Off" position
         * @type {string}
         */
        this.offText = 'Off';
        /**
         * Bootstrap color scheme when toggled in the "On" position (i.e. "primary" translates to "btn-primary")
         * @type {string}
         */
        this.onColor = 'primary';
        /**
         * Bootstrap color scheme when toggled in the "Off" position (i.e. "primary" translates to "btn-primary")
         * @type {string}
         */
        this.offColor = 'secondary';
        /**
         * Button size to display the toggle
         * @type {string}
         */
        this.size = '';
        /**
         * Whether the toggle is disabled or not
         * @type {boolean}
         */
        this.disabled = false;
        /**
         * An event fired when the user causes a change.
         * The payload of the event is the currently selected value.
         * @type {EventEmitter<boolean>}
         */
        this.valueChange = new EventEmitter();
        this.width = 0;
        this.handleWidth = 0;
        this._animate = true;
        this._innerAnimate = true;
        this._innerState = false;
        this._innerWidth = 'auto';
        this._dragStart = null;
        this._dragEnd = null;
        this._initialized = false;
        this._hidden = false;
    }
    Object.defineProperty(NgxToggle.prototype, "value", {
        get: function () {
            return this._innerState;
        },
        /**
         * @param {boolean} value
         */
        set: function (value) {
            this.setState(value);
        },
        enumerable: true,
        configurable: true
    });
    NgxToggle.prototype.ngAfterViewInit = function () {
        this.calculateWidth();
        this._initialized = true;
    };
    NgxToggle.prototype.ngAfterViewChecked = function () {
        var hidden = this.elRef.nativeElement.offsetParent === null;
        if (this._initialized && this._hidden && !hidden) {
            this.calculateWidth();
        }
        this._hidden = hidden;
    };
    NgxToggle.prototype.ngAfterContentInit = function () {
        var onElement = this.labelElements.find(function (item) { return item.forLabel.toLowerCase() === 'on'; });
        var offElement = this.labelElements.find(function (item) { return item.forLabel.toLowerCase() === 'off'; });
        if (onElement) {
            this.onLabel = onElement;
        }
        if (offElement) {
            this.offLabel = offElement;
        }
        if (onElement || offElement) {
            this.calculateWidth(true);
        }
    };
    NgxToggle.prototype.ngOnChanges = function (changes) {
        if (changes['onText'] || changes['offText'] || changes['size']) {
            this._initialized = false;
            this.calculateWidth(this._initialized);
            this._initialized = true;
        }
    };
    Object.defineProperty(NgxToggle.prototype, "btnClasses", {
        get: function () {
            var btnClasses = {
                'disabled': this.disabled,
                'ngx-toggle-lg': this.size === 'lg',
                'ngx-toggle-sm': this.size === 'sm',
                'btn-lg': this.size === 'lg',
                'btn-sm': this.size === 'sm',
                'ngx-toggled-on': this.innerState === true,
                'ngx-toggled-off': this.innerState === false,
                'ngx-toggle-indeterminate': this.indeterminate,
                'ngx-toggle-animate': this.animate,
                'ngx-toggle-disabled': this.disabled
            };
            btnClasses[this.activeClass] = this.value;
            btnClasses[this.inactiveClass] = !this.value;
            if (this.activeClass === this.inactiveClass) {
                btnClasses[this.activeClass] = true;
            }
            return btnClasses;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxToggle.prototype, "handleClass", {
        get: function () {
            var handleClass = 'btn-light';
            var classes = { 'disabled': this.disabled, 'btn-lg': this.size === 'lg', 'btn-sm': this.size === 'sm' };
            if ((this.value && this.onColor === 'light') || (!this.value && this.offColor === 'light')) {
                handleClass = 'btn-dark';
            }
            classes[handleClass] = true;
            return classes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxToggle.prototype, "onClasses", {
        get: function () {
            var classes = { 'disabled': this.disabled, 'btn-lg': this.size === 'lg', 'btn-sm': this.size === 'sm' };
            classes['btn-' + this.onColor] = true;
            return classes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxToggle.prototype, "offClasses", {
        get: function () {
            var classes = { 'disabled': this.disabled, 'btn-lg': this.size === 'lg', 'btn-sm': this.size === 'sm' };
            classes['btn-' + this.offColor] = true;
            return classes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxToggle.prototype, "indeterminate", {
        get: function () {
            return this._innerState === null || typeof this._innerState === 'undefined';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxToggle.prototype, "activeClass", {
        get: function () {
            return 'btn-' + this.onColor;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxToggle.prototype, "inactiveClass", {
        get: function () {
            return 'btn-' + this.offColor;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxToggle.prototype, "innerState", {
        get: function () {
            return this._innerState;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxToggle.prototype, "animate", {
        get: function () {
            return this._animate;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxToggle.prototype, "marginLeft", {
        get: function () {
            var margin = 0;
            if (!this._initialized) {
            }
            else if (this.indeterminate || this._innerState === null || typeof this._innerState === 'undefined') {
                margin = -(this.width / 2);
            }
            else if (this._dragEnd) {
                margin = this._dragEnd;
            }
            else if (!this._innerState) {
                margin = -this.width;
            }
            return margin + 'px';
        },
        enumerable: true,
        configurable: true
    });
    NgxToggle.prototype.handleClick = function () {
        if (!this.disabled && !this._dragEnd) {
            this.setState(!this._innerState);
        }
        else if (this._dragEnd) {
            this._dragEnd = null;
        }
    };
    NgxToggle.prototype.onTouchStart = function (event) {
        this.onDragStart(event);
    };
    NgxToggle.prototype.onMouseDown = function (event) {
        this.onDragStart(event);
    };
    NgxToggle.prototype.onTouchMove = function (event) {
        this.onDragMove(event);
    };
    NgxToggle.prototype.onMouseMove = function (event) {
        this.onDragMove(event);
    };
    NgxToggle.prototype.onTouchEnd = function (event) {
        this.onDragEnd(event, true);
    };
    NgxToggle.prototype.onMouseUp = function (event) {
        this.onDragEnd(event);
    };
    NgxToggle.prototype.onMouseLeave = function (event) {
        this.onDragEnd(event, true);
    };
    NgxToggle.prototype.onKeyDown = function (event) {
        if (!event.key || this.disabled) {
            return;
        }
        switch (event.key) {
            case 'Left':
                event.preventDefault();
                event.stopImmediatePropagation();
                this.setState(false);
                break;
            case 'Right':
                event.preventDefault();
                event.stopImmediatePropagation();
                this.setState(true);
                break;
        }
    };
    NgxToggle.prototype.onDragStart = function (event) {
        if (event.target === this.handle$) {
            if (this._dragStart || this.disabled) {
                return;
            }
            event.preventDefault();
            event.stopPropagation();
            this._dragStart = (event.pageX || event.touches[0].pageX) - parseInt(this.container$.style.marginLeft, 10);
            if (this._animate) {
                this._animate = !this._animate;
            }
        }
    };
    NgxToggle.prototype.onDragMove = function (event) {
        if (this._dragStart) {
            event.preventDefault();
            var difference = (event.pageX || event.touches[0].pageX) - this._dragStart;
            if (difference < -(Number(this.width)) || difference > 0) {
                return;
            }
            this._dragEnd = difference;
        }
    };
    NgxToggle.prototype.onDragEnd = function (event, clearDragEnd) {
        if (clearDragEnd === void 0) { clearDragEnd = false; }
        if (this._dragStart) {
            event.preventDefault();
            event.stopPropagation();
            if (this._dragEnd) {
                this.setState(this._dragEnd > -(Number(this.width) / 2));
            }
            this._dragStart = null;
            if (clearDragEnd) {
                this._dragEnd = null;
            }
            if (this._innerAnimate) {
                this._animate = true;
            }
        }
    };
    NgxToggle.prototype.calculateWidth = function (disableAnimation) {
        var _this = this;
        if (disableAnimation === void 0) { disableAnimation = false; }
        if (disableAnimation && this._innerAnimate) {
            this._animate = false;
        }
        var initialized = this._initialized;
        if (!initialized) {
            this.container$.style.width = 'auto';
            this.wrapper$.style.width = 'auto';
        }
        this.on$.style.width = 'auto';
        this.off$.style.width = 'auto';
        setTimeout(function () {
            var width = _this._innerWidth;
            if (_this._innerWidth === 'auto') {
                width = Math.max(_this.on$.offsetWidth, _this.off$.offsetWidth);
            }
            _this.handleWidth = _this.handle$.offsetWidth;
            _this.width = Number(width);
            if (!initialized) {
                _this.container$.style.width = ((_this.width * 2) + _this.handleWidth) + 'px';
                _this.wrapper$.style.width = (_this.width + _this.handleWidth) + 'px';
            }
            _this.ngZone.run(function () {
                _this.on$.style.width = _this.width + 'px';
                _this.off$.style.width = _this.width + 'px';
                setTimeout(function () {
                    if (disableAnimation && _this._innerAnimate) {
                        _this._animate = true;
                    }
                });
            });
        });
    };
    NgxToggle.prototype.setState = function (value) {
        if (value !== this._innerState) {
            this._innerState = value;
            this.valueChange.emit(this._innerState);
        }
    };
    Object.defineProperty(NgxToggle.prototype, "wrapper$", {
        get: function () {
            return this.wrapperElement.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxToggle.prototype, "on$", {
        get: function () {
            return this.onElement.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxToggle.prototype, "off$", {
        get: function () {
            return this.offElement.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxToggle.prototype, "handle$", {
        get: function () {
            return this.handleElement.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxToggle.prototype, "container$", {
        get: function () {
            return this.containerElement.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    NgxToggle.decorators = [
        { type: Component, args: [{
                    selector: 'ngx-toggle',
                    template: "\n        <div #wrapper class=\"ngx-toggle-wrapper btn\" [ngClass]=\"btnClasses\">\n            <div #container class=\"ngx-toggle-container\"\n                 [style.margin-left]=\"marginLeft\"\n            >\n            <span #on class=\"ngx-toggle-on btn\" [ngClass]=\"onClasses\">\n                <ng-template [ngTemplateOutlet]=\"onLabel?.templateRef\"></ng-template>\n                <ng-container *ngIf=\"!onLabel\">{{onText}}</ng-container>\n            </span>\n                <span #handle class=\"ngx-toggle-handle btn\" [ngClass]=\"handleClass\">&nbsp;</span>\n                <span #off class=\"ngx-toggle-off btn\" [ngClass]=\"offClasses\">\n                <ng-template [ngTemplateOutlet]=\"offLabel?.templateRef\"></ng-template>\n                <ng-container *ngIf=\"!offLabel\">{{offText}}</ng-container>\n            </span>\n            </div>\n            <ng-content></ng-content>\n        </div>\n    ",
                    styles: [
                        ':host {position: relative; display: inline-block;}',
                        ".ngx-toggle-container, .ngx-toggle-on, .ngx-toggle-off, .ngx-toggle-handle {\n            display: -webkit-box !important;\n            display: -webkit-flex !important;\n            display: -ms-flexbox !important;\n            display: flex !important;\n        }",
                        ".ngx-toggle-wrapper {\n            position:       relative;\n            display:        block;\n            direction:      ltr;\n            cursor:         pointer;\n            overflow:       hidden;\n            padding:        0;\n            text-align:     left;\n            z-index:        0;\n            user-select:    none;\n            vertical-align: middle;\n            transition:     border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;\n            box-sizing:     content-box;\n        }",
                        '.ngx-toggle-wrapper.disabled,.ngx-toggle-wrapper.disabled .btn{cursor: default;}',
                        '.ngx-toggle-wrapper input{position: absolute; z-index: -1; visibility: hidden; width: 1px; height: 1px;}',
                        '.ngx-toggle-container{align-items: stretch!important; top: 0; border-radius: 0; transform: translateZ(0);}',
                        '.ngx-toggle-wrapper.ngx-toggle-animate .ngx-toggle-container {transition: margin-left 0.5s;}',
                        '.ngx-toggle-on,.ngx-toggle-off {align-items: center!important; text-align: center; z-index: 1; border-radius: 0;}',
                        ".ngx-toggle-on, .ngx-toggle-off, .ngx-toggle-handle {\n            box-sizing:  border-box;\n            cursor:      pointer;\n            user-select: none;\n        }",
                        ".ngx-toggle-handle {\n            text-align:    center;\n            margin-top:    -1px;\n            margin-bottom: -1px;\n            z-index:       100;\n            width:         1em;\n            padding-left:  0;\n            padding-right: 0;\n            align-self:    stretch !important;\n        }"
                    ],
                    preserveWhitespaces: false,
                    encapsulation: ViewEncapsulation.None
                },] },
    ];
    /** @nocollapse */
    NgxToggle.ctorParameters = function () { return [
        { type: NgZone },
        { type: ElementRef }
    ]; };
    NgxToggle.propDecorators = {
        onText: [{ type: Input }],
        offText: [{ type: Input }],
        onColor: [{ type: Input }],
        offColor: [{ type: Input }],
        size: [{ type: Input }],
        disabled: [{ type: Input }],
        value: [{ type: Input }],
        valueChange: [{ type: Output }],
        wrapperElement: [{ type: ViewChild, args: ['wrapper',] }],
        containerElement: [{ type: ViewChild, args: ['container',] }],
        onElement: [{ type: ViewChild, args: ['on',] }],
        offElement: [{ type: ViewChild, args: ['off',] }],
        handleElement: [{ type: ViewChild, args: ['handle',] }],
        labelElements: [{ type: ContentChildren, args: [NgxToggleLabel,] }],
        handleClick: [{ type: HostListener, args: ['click',] }],
        onTouchStart: [{ type: HostListener, args: ['touchstart', ['$event'],] }],
        onMouseDown: [{ type: HostListener, args: ['mousedown', ['$event'],] }],
        onTouchMove: [{ type: HostListener, args: ['touchmove', ['$event'],] }],
        onMouseMove: [{ type: HostListener, args: ['mousemove', ['$event'],] }],
        onTouchEnd: [{ type: HostListener, args: ['touchend', ['$event'],] }],
        onMouseUp: [{ type: HostListener, args: ['mouseup', ['$event'],] }],
        onMouseLeave: [{ type: HostListener, args: ['mouseleave', ['$event'],] }],
        onKeyDown: [{ type: HostListener, args: ['keydown', ['$event'],] }]
    };
    return NgxToggle;
}());
export { NgxToggle };
var NgxToggleAccessor = /** @class */ (function () {
    function NgxToggleAccessor(_host) {
        var _this = this;
        this._host = _host;
        this._subscription = this._host.valueChange.subscribe(function (value) { return _this.onChange(value); });
    }
    NgxToggleAccessor.prototype.ngOnDestroy = function () {
        if (this._subscription) {
            this._subscription.unsubscribe();
            this._subscription = null;
        }
    };
    NgxToggleAccessor.prototype.onChange = function (_) {
        if (this._onChange) {
            this._onChange(this._host.value);
        }
    };
    NgxToggleAccessor.prototype.onTouched = function () {
        if (this._onTouched) {
            this._onTouched();
        }
    };
    NgxToggleAccessor.prototype.registerOnChange = function (fn) {
        this._onChange = fn;
    };
    NgxToggleAccessor.prototype.registerOnTouched = function (fn) {
        this._onTouched = fn;
    };
    NgxToggleAccessor.prototype.setDisabledState = function (isDisabled) {
        this._host.disabled = isDisabled;
    };
    NgxToggleAccessor.prototype.writeValue = function (obj) {
        if (typeof obj === 'boolean' || obj === null) {
            this._host.value = obj;
        }
    };
    NgxToggleAccessor.decorators = [
        { type: Directive, args: [{
                    selector: 'ngx-toggle',
                    host: { '(change)': 'onChange($event)', '(touch)': 'onTouched()' },
                    providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(function () { return NgxToggleAccessor; }), multi: true }]
                },] },
    ];
    /** @nocollapse */
    NgxToggleAccessor.ctorParameters = function () { return [
        { type: NgxToggle }
    ]; };
    return NgxToggleAccessor;
}());
export { NgxToggleAccessor };
//# sourceMappingURL=toggle.js.map