import { AfterContentInit, AfterViewChecked, AfterViewInit, ElementRef, EventEmitter, NgZone, OnChanges, OnDestroy, QueryList, SimpleChanges, TemplateRef } from '@angular/core';
import { ControlValueAccessor } from '@angular/forms';
/**
 * The NgxToggleLabel directive allows you to customize the label for the "On" and "Off" states,
 * allowing for more robust and complex displays.
 * This directive must be used in conjunction with a ng-template.
 */
export declare class NgxToggleLabel {
    templateRef: TemplateRef<any>;
    private elRef;
    /**
     * Determines which state the label will be used.
     */
    forLabel: 'on' | 'off';
    constructor(templateRef: TemplateRef<any>, elRef: ElementRef);
    readonly element: ElementRef;
}
/**
 * The NgxToggle directive allows for standalone or checkbox-enabled switch toggling via a UI element.
 * The toggle is styled using Bootstrap v4+ classes.
 */
export declare class NgxToggle implements AfterViewInit, AfterContentInit, AfterViewChecked, OnChanges {
    private ngZone;
    private elRef;
    /**
     * Display text when toggled in the "On" position
     * @type {string}
     */
    onText: string;
    /**
     * Display text when toggled in the "Off" position
     * @type {string}
     */
    offText: string;
    /**
     * Bootstrap color scheme when toggled in the "On" position (i.e. "primary" translates to "btn-primary")
     * @type {string}
     */
    onColor: string;
    /**
     * Bootstrap color scheme when toggled in the "Off" position (i.e. "primary" translates to "btn-primary")
     * @type {string}
     */
    offColor: string;
    /**
     * Button size to display the toggle
     * @type {string}
     */
    size: 'sm' | 'lg' | '';
    /**
     * Whether the toggle is disabled or not
     * @type {boolean}
     */
    disabled: boolean;
    /**
     * @param {boolean} value
     */
    value: boolean;
    /**
     * An event fired when the user causes a change.
     * The payload of the event is the currently selected value.
     * @type {EventEmitter<boolean>}
     */
    valueChange: EventEmitter<boolean>;
    width: number;
    handleWidth: number;
    wrapperElement: ElementRef;
    containerElement: ElementRef;
    onElement: ElementRef;
    offElement: ElementRef;
    handleElement: ElementRef;
    labelElements: QueryList<NgxToggleLabel>;
    onLabel: NgxToggleLabel;
    offLabel: NgxToggleLabel;
    private _animate;
    private _innerAnimate;
    private _innerState;
    private _innerWidth;
    private _dragStart;
    private _dragEnd;
    private _initialized;
    private _hidden;
    constructor(ngZone: NgZone, elRef: ElementRef);
    ngAfterViewInit(): void;
    ngAfterViewChecked(): void;
    ngAfterContentInit(): void;
    ngOnChanges(changes: SimpleChanges): void;
    readonly btnClasses: any;
    readonly handleClass: any;
    readonly onClasses: any;
    readonly offClasses: any;
    readonly indeterminate: boolean;
    readonly activeClass: string;
    readonly inactiveClass: string;
    readonly innerState: boolean;
    readonly animate: boolean;
    readonly marginLeft: string;
    handleClick(): void;
    onTouchStart(event: any): void;
    onMouseDown(event: any): void;
    onTouchMove(event: any): void;
    onMouseMove(event: any): void;
    onTouchEnd(event: any): void;
    onMouseUp(event: any): void;
    onMouseLeave(event: any): void;
    onKeyDown(event: KeyboardEvent): void;
    private onDragStart(event);
    private onDragMove(event);
    private onDragEnd(event, clearDragEnd?);
    private calculateWidth(disableAnimation?);
    private setState(value);
    private readonly wrapper$;
    private readonly on$;
    private readonly off$;
    private readonly handle$;
    private readonly container$;
}
export declare class NgxToggleAccessor implements ControlValueAccessor, OnDestroy {
    private _host;
    private _onChange;
    private _onTouched;
    private _subscription;
    constructor(_host: NgxToggle);
    ngOnDestroy(): void;
    onChange(_: any): void;
    onTouched(): void;
    registerOnChange(fn: any): void;
    registerOnTouched(fn: any): void;
    setDisabledState?(isDisabled: boolean): void;
    writeValue(obj: any): void;
}
